<?xml version="1.0" encoding="utf-8" ?>
<Math>
  <CoherentNoise>
    <AboutPerlin>
      <remarks>
        Perlin noise is a coherent, pseudo-random noise source developed by Ken Perlin in the 1980s. It won him an
        academy award, as the technique quickly became ubiquitous in the generation of all kinds of procedural textures
        for use in computer graphics. Perlin noise has some minor flaws, however. These include computational
        complexity that increases exponentially with the number of dimensions and minor directional artifacts due to
        its anisotropy. These have been mostly rectified by the creation of Simplex noise, which is also implemented
        in this class. This class implements the improvements to Perlin noise that Ken Perlin published in 2002,
        which eliminate some of the artifacts.
      </remarks>
    </AboutPerlin>

    <AboutSimplex>
      <remarks>
        Simplex noise is a coherent, pseudo-random noise source developed by Ken Perlin in 2001 to address the flaws in
        his earlier Perlin noise algorithm. Simplex noise is substantially faster than Perlin noise above 3 dimensions,
        is visually isotropic, and is easy to implement in hardware. It can be used for the same tasks to which Perlin
        noise is typically applied.
      </remarks>
    </AboutSimplex>
  </CoherentNoise>

  <Common>
    <GetHashCode>Returns a hash code for the object.</GetHashCode>
  </Common>

  <Financial>
    <CumulativeInterest>
      <summary>Returns the cumulative interest paid between two periods of a loan or other annuity.</summary>
      <param name="rate">The interest rate of the loan or investment, or the discount rate of the annuity, per period</param>
      <param name="payment">The payment per period, positive for cash received and negative for cash paid. If omitted, the payment will be
        calculated based on the other parameters, but if this method will be called multiple times for the same annuity, it is more
        efficient to calculate the payment once and provide it as a parameter. Also, you must specify the payment if it differs from the
        standard payment for the loan or annuity. Note that if you specify a non-standard payment, this method will not be aware of how
        that impacts other loan parameters; for example, it assumes all payments are the same size and is not aware that with a
        non-standard payment, the final payment may be smaller than the others.
      </param>
      <param name="firstPeriod">The beginning of the periods whose cumulative interest payments should be returned, where 0 is the first
        period in the loan or annuity
      </param>
      <param name="periodCount">The number of periods whose cumulative interest payments should be returned, starting from
        <paramref name="firstPeriod"/>
      </param>
      <param name="paymentCount">The total number of payment periods in the loan or other annuity</param>
      <param name="presentValue">The the amount received as a loan (positive), or the present value that would have to be paid to
        purchase the investment (negative), or zero if the future value will come from the payments alone
      </param>
      <param name="futureValue">The future balance of the loan (negative) or value of the investment (positive) after the last
        payment. You may specify zero, if the loan would be completely paid off or the investment would be completely sold or after the
        last payment. If omitted, the value is zero.
      </param>
      <param name="payAtEnd">If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments
        are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods have a chance
        to earn interest. If omitted, the value is true.
      </param>
      <returns>Returns the total amount of interest added to the balance of the loan or present value of the investment during the
        given payment periods.
      </returns>
      <example>
        You take out a $500,000 home loan at 5% APR (compounded monthly) over 30 years and want to know how much interest will be
        paid in the first year compared to the last year, so you take rate = <c>0.05 / 12</c> (5% APR compounded monthly), firstPeriod = 0 (the
        start of the first year), periodCount = 12 (the length of the first year, in months), paymentCount = 30*12 (because it's a
        30-year loan paid monthly), presentValue = 500,000, and payAtEnd = true (as is typical for mortgages). You get -$24,832.47
        (negative because you must pay it). To check the last year, you do the same calculation but with firstPeriod = 29*12 (the start
        of the 29th year) and get -$855.63.
      </example>
    </CumulativeInterest>
    <CumulativePrincipal>
      <summary>Returns the cumulative principal paid between two periods of a loan or other annuity.</summary>
      <param name="rate">The interest rate of the loan or investment, or the discount rate of the annuity, per period</param>
      <param name="payment">
        The payment per period, positive for cash received and negative for cash paid. If omitted, the payment will be
        calculated based on the other parameters, but if this method will be called multiple times for the same annuity, it is more
        efficient to calculate the payment once and provide it as a parameter. Also, you must specify the payment if it differs from the
        standard payment for the loan or annuity. Note that if you specify a non-standard payment, this method will not be aware of how
        that impacts other loan parameters; for example, it assumes all payments are the same size and is not aware that with a
        non-standard payment, the final payment may be smaller than the others.
      </param>
      <param name="firstPeriod">The beginning of the periods whose cumulative principal payments should be returned, where 0 is the first
        period in the loan or annuity
      </param>
      <param name="periodCount">The number of periods whose cumulative principal payments should be returned, starting from
        <paramref name="firstPeriod"/>
      </param>
      <param name="paymentCount">The total number of payment periods in the loan or other annuity</param>
      <param name="presentValue">The the amount received as a loan (positive), or the present value that would have to be paid to
        purchase the investment (negative), or zero if the future value will come from the payments alone
      </param>
      <param name="futureValue">The future balance of the loan (negative) or value of the investment (positive) after the last
        payment. You may specify zero, if the loan would be completely paid off or the investment would be completely sold or after the
        last payment. If omitted, the value is zero.
      </param>
      <param name="payAtEnd">If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments
        are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods have a chance
        to earn interest. If omitted, the value is true.
      </param>
      <returns>Returns the total amount of principal added to the balance of the loan or present value of the investment during the
        given payment periods.
      </returns>
      <example>
        You take out a $500,000 home loan at 5% APR (compounded monthly) over 30 years and want to know how much of the principal will be
        paid in the first year compared to the last year, so you take rate = <c>0.05 / 12</c> (5% APR compounded monthly),
        firstPeriod = 0 (the start of the first year), periodCount = 12 (the length of the first year, in months), paymentCount = 30*12
        (because it's a 30-year loan paid monthly), presentValue = 500,000, and payAtEnd = true (as is typical for mortgages). You get
        -$7,376.83 (negative because you must pay it). To check the last year, you do the same calculation but with firstPeriod = 29*12
        (the start of the 29th year) and get -$31,353.66.
      </example>
    </CumulativePrincipal>
    <FutureValue>
      <summary>Computes the future value of an annuity, investment, or loan.</summary>
      <param name="rate">The interest rate of the investment or loan, or the discount rate of the annuity, per period</param>
      <param name="payment">The payment per period, positive for cash received and negative for cash paid</param>
      <param name="paymentCount">The number of payment periods</param>
      <param name="presentValue">
        The present value that would have to be paid to purchase the investment (negative), or the amount received as a loan (positive),
        or zero if the future value will come from the payments alone. If omitted, the value is zero.
      </param>
      <param name="payAtEnd">
        If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false,
        payments are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods
        have a chance to earn interest. If omitted, the value is true.
      </param>
      <returns>
        Returns the future value, positive if you would have an asset in the future and negative if you would have a liability
        in the future.
      </returns>
      <example>
        To compute how much you would have if you started with $3000 and saved $500 at the end of each month for ten years while
        earning 5% APY compounded monthly, use rate = <c>PeriodicRate(.05, 12)</c> (5% APY compounded monthly), payment = -500 (negative
        because you are paying), paymentCount = 10*12 (ten years of monthly payments), presentValue = -3000 (because you started by
        depositing (paying) $3000 into your account), and payAtEnd = true (because you are depositing money at the end of each month).
        The result is $82,068.26 (positive because this is an asset), indicating that you'd have that much money after 10 years.
      </example>
    </FutureValue>
    <Interest>
      <summary>Computes the amount of interest paid in a single period of a loan.</summary>
      <param name="rate">The interest rate of the loan or investment, or the discount rate of the annuity, per period</param>
      <param name="payment">
        The payment per period, positive for cash received and negative for cash paid. If omitted, the payment will be
        calculated based on the other parameters, but if this method will be called multiple times, it is more efficient to calculate the
        payment once and provide it as a parameter. Also, you must specify the payment if it differs from the
        standard payment for the loan or annuity. Note that if you specify a non-standard payment, this method will not be aware of how
        that impacts other loan parameters; for example, it assumes all payments are the same size and is not aware that with a
        non-standard payment, the final payment may be smaller than the others.
      </param>
      <param name="period">The payment period whose interest payment should be returned, from 0 to <paramref name="paymentCount"/>. If
      <paramref name="period"/> is <paramref name="paymentCount"/>, the interest rate of a hypothetical next payment after the last payment
        will be returned.
      </param>
      <param name="paymentCount">The number of payment periods</param>
      <param name="presentValue">The the amount received as a loan (positive), or the present value that would have to be paid to
        purchase the investment (negative), or zero if the future value will come from the payments alone
      </param>
      <param name="futureValue">The future balance of the loan (negative) or value of the investment (positive) after the last
        payment. You may specify zero, if the loan would be completely paid off or the investment would be completely sold after the
        last payment. If omitted, the value is zero.
      </param>
      <param name="payAtEnd">If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments
        are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods have a chance
        to earn interest. If omitted, the value is true.
      </param>
      <returns>Returns the amount of interest paid (negative) or received (positive) during the given period.</returns>
      <example>
        You take out a $500,000 home loan at 5% APR (compounded monthly) over 30 years and are surprised to see that of your first $2,684.11
        monthly payment, $2,083.33 goes to interest and only $600.78 goes to reduce your principal. You wonder what the situation will look
        like in 10 years, so you take rate = <c>0.05 / 12</c> (5% APR compounded monthly), period = 10*12 (the first month of the 10th year),
        paymentCount = 30*12 (because it's a 30-year loan paid monthly), presentValue = 500,000 (the value of the loan), and payAtEnd = true
        (as is typical for mortgages). You get -$1,694.63 (negative since you must pay it), indicating that even after 10 years, $1,694.63
        goes to interest and only $989.48 goes to principal. As a result, you resolve to pay extra each month to reduce your principal more
        quickly.
      </example>
    </Interest>
    <Payment>
      <summary>Computes the periodic payment needed to bring an annuity, loan, or investment from its present value to a future value.</summary>
      <param name="rate">The interest rate of the loan or investment, or the discount rate of the annuity, per period</param>
      <param name="paymentCount">The number of payment periods</param>
      <param name="presentValue">
        The present value that would have to be paid to purchase the investment (negative), or the amount
        received as a loan (positive), or zero if the future value will come from the payments alone.
      </param>
      <param name="futureValue">
        The future value of the investment (positive) or the balance of the loan (negative) after the last
        payment. You may specify zero, if the investment would be completely sold or the loan paid off after the last payment. If
        omitted, the value is zero.
      </param>
      <param name="payAtEnd">
        If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments
        are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods have a chance
        to earn interest. If omitted, the value is true.
      </param>
      <returns>
        Returns the payment amount needed to reach the future value over the given number of periods, negative if you must pay
        to transform the value and positive if you will be paid. The value will be a non-integer if the future value will not be reached
        exactly at the start or end of any period.
      </returns>
      <example>
        You want to take a $10,000 personal loan. The bank is willing to offer you the money at 8% APR (compounded monthly), and
        you want to know what your monthly payment would need to be in order to pay it back within 4 years. Take rate = <c>0.08 / 12</c>
        (8% APR compounded monthly), paymentCount = 4*12 (four years of monthly payments), presentValue = 10,000 (positive because the
        lender gave you money), futureValue = 0 (because you expect to fully repay the loan after four years), and payAtEnd = true (because
        the bank changes interest before the first payment is due). The result is -$244.13 per month, which is negative because you'll have
        to pay that amount.
        <para>
          It's October and you've had a child. You want to save $75,000 over the next 18 years for his college tuition. You expect
          the market to return at least 5% per year and want to know how much you'll need to divert from your Christmas bonus to reach your
          goal. Take rate = 0.05 (5%), paymentCount = 18, presentValue = 0 (because you don't have anything saved yet), futureValue = 75,000,
          and payAtEnd = false (because you'll be depositing money from your Christmas bonus which is near the beginning of the 12-month
          period starting from October). The result is about -$2,539, which is negative because you'll have to pay it each Christmas.
        </para>
      </example>
    </Payment>
    <Periods>
      <summary>Computes the number of periods needed to bring an annuity, loan, or investment from its present value to a future value.</summary>
      <param name="rate">The interest rate of the loan or investment, or the discount rate of the annuity, per period</param>
      <param name="payment">The payment per period, positive for cash received and negative for cash paid</param>
      <param name="presentValue">
        The present value that would have to be paid to purchase the investment (negative), or the amount
        received as a loan (positive), or zero if the future value will come from the payments alone.
      </param>
      <param name="futureValue">
        The future value of the investment (positive) or the balance of the loan (negative) after the last
        payment. You may specify zero, if the investment would be completely sold or the loan paid off after the last payment. If
        omitted, the value is zero.
      </param>
      <param name="payAtEnd">
        If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments
        are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods have a chance
        to earn interest. If omitted, the value is true.
      </param>
      <returns>
        Returns the number of periods needed for the investment to reach the future value (zero if omitted). The value will be
        negative if the "future" value was actually reached in the past (i.e. if the future value can't be reached because the value is
        changing in the wrong direction). A non-integer value will be returned if the future value would not be reached at the exact
        start or end of a period.
      </returns>
      <example>
        You're considering taking a loan for $100,000 at 5% APR compounded monthly with a $1000 monthly payment, and want to know
        how long it would take to pay it off. Take rate = <c>.05 / 12</c> (5% APR compounded monthly), payment = -1000 (negative
        because you're paying), presentValue = 100,000 (positive because you received the money from the lender), futureValue = 0 (because
        you intend to repay the entire loan), and payAtEnd = true (because for this loan the interest is charged before the first payment).
        The result is about 129.63, meaning it will take that many months to pay it off. Dividing by 12, you get 10.8 years.
        <para>
          You have $2000 in your savings account which pays 2.5% APY (compounded monthly) and want to know how long it will take to reach
          $2200. Take rate = <c>PeriodicRate(0.025, 12)</c> (2.5% APY compounded monthly), payment = 0 (because you're not making additional
          deposits), presentValue = -2000 (negative because you "paid" (deposited) money to create this investment), and futureValue = 2200
          (positive because you'll be able to "sell" (withdraw) your investment at the end). The result is about 46.32 months or 3.9 years.
        </para>
      </example>
    </Periods>
    <PresentValue>
      <summary>Computes the present value of an annuity, loan, or investment.</summary>
      <param name="rate">The interest rate of the loan or investment, or the discount rate of the annuity, per period</param>
      <param name="payment">The payment per period, positive for cash received and negative for cash paid</param>
      <param name="paymentCount">The number of payment periods</param>
      <param name="futureValue">
        The future value of the investment (positive) or the balance of the loan (negative) after the last payment. You may specify zero,
        if the investment would be completely sold or the loan paid off after the last payment. If omitted, the value is zero.
      </param>
      <param name="payAtEnd">
        If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments are made
        at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods
        have a chance to earn interest. If omitted, the value is true.
      </param>
      <returns>Returns the present value, positive if you receive cash in the present and negative if you pay cash in the present.</returns>
      <example>
        To compute how much you would have to pay right now to obtain $100,000 in ten years assuming you had a savings account
        that paid 5% APY (compounded monthly) and assuming that you would deposit $250 per month, use rate = <c>PeriodicRate(.05, 12)</c>
        (5% APY compounded monthly), payment = -250 (negative because you are paying), paymentCount = 10*12 (ten years of monthly payments),
        futureValue = 100,000 (the amount you want to have at the end), and payAtEnd = true (because you'll make the first $250 payment
        after the first month). The result is -$37,699.93, meaning that you'd need to start with a
        lump sum payment of $37,699.93 under those conditions to reach $100,000 in ten years.
        <para>
          To compute how expensive of a house you could afford assuming you have $50,000 saved for a down payment and are able to pay
          $1,250 per month over 30 years to service the loan, and assuming you can get an interest rate of 5% APR, use rate = <c>0.05 / 12</c>
          (5% APR paid monthly), payment = -1250 (negative because you are paying), paymentCount = 30*12 (30 years of monthly payments),
          futureValue = 0 (because you'll have paid off the loan at the end of 30 years), and payAtEnd = true (since that's how mortgages
          work). The result is about $232,852 (positive since you are being paid that much by the lender), which is the amount of loan
          principal you can afford. Adding the down payment, you get $282,852 as the most expensive house you can afford.
        </para>
        <para>
          To compute how much you'd need to pay to establish an annuity that pays you $1000/mo for 20 years and has a fixed interest
          rate of 5% APY (compounded daily), use rate = <c>PeriodicRate(.05, 365.25)</c> (5% APY compounded daily), payment = 1000 (positive
          because you are being paid), paymentCount = 20*12 (20 years of monthly payments), futureValue = 0 (because the annuity will be
          exhausted at the end of 20 years), and payAtEnd = true (as is typical for annuities). The result is -$236,177.90 (negative because
          you must pay this lump sum in the present to establish the annuity).
        </para>
      </example>
    </PresentValue>
    <Principal>
      <summary>Computes the amount of principal paid in a single period of a loan.</summary>
      <param name="rate">The interest rate of the loan or investment, or the discount rate of the annuity, per period</param>
      <param name="payment">
        The payment per period, positive for cash received and negative for cash paid. If omitted, the payment will be
        calculated based on the other parameters, but if this method will be called multiple times for the same annuity, it is more
        efficient to calculate the payment once and provide it as a parameter. Also, you must specify the payment if it differs from the
        standard payment for the loan or annuity. Note that if you specify a non-standard payment, this method will not be aware of how
        that impacts other loan parameters; for example, it assumes all payments are the same size and is not aware that with a
        non-standard payment, the final payment may be smaller than the others.
      </param>
      <param name="period">The payment period whose principal payment should be returned, from 0 to <paramref name="paymentCount"/>-1</param>
      <param name="paymentCount">The number of payment periods</param>
      <param name="presentValue">The the amount received as a loan (positive), or the present value that would have to be paid to
        purchase the investment (negative), or zero if the future value will come from the payments alone
      </param>
      <param name="futureValue">The future balance of the loan (negative) or value of the investment (positive) after the last
        payment. You may specify zero, if the loan would be completely paid off or the investment would be completely sold after the
        last payment. If omitted, the value is zero.
      </param>
      <param name="payAtEnd">If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments
        are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods have a chance
        to earn interest. If omitted, the value is true.
      </param>
      <returns>Returns the amount of principal added to the balance of the loan or present value of the investment during the given payment
        period.
      </returns>
      <example>
        You take out a $500,000 home loan at 5% APR (compounded monthly) over 30 years and are surprised to see that of your first $2,684.11
        monthly payment, $2,083.33 goes to interest and only $600.78 goes to reduce your principal. You wonder what the situation will look
        like in 10 years, so you take rate = <c>0.05 / 12</c> (5% APR compounded monthly), period = 10*12 (the first month of the 10th year),
        paymentCount = 30*12 (because it's a 30-year loan paid monthly), presentValue = 500,000 (the value of the loan), and payAtEnd = true
        (as is typical for mortgages). You get -$989.48 (negative since you must pay it), indicating that even after 10 years, only $989.48
        goes to principal and $1,694.63 goes to interest. As a result, you resolve to pay extra each month to reduce your principal more quickly.
      </example>
    </Principal>
    <Rate>
      <summary>Computes the interest rate needed to bring an annuity, loan, or investment from its present value to a future value.</summary>
      <param name="payment">The payment per period, positive for cash received and negative for cash paid</param>
      <param name="paymentCount">The number of payment periods</param>
      <param name="presentValue">
        The present value that would have to be paid to purchase the investment (negative), or the amount
        received as a loan (positive), or zero if the future value will come from the payments alone.
      </param>
      <param name="futureValue">
        The future value of the investment (positive) or the balance of the loan (negative) after the last
        payment. You may specify zero, if the investment would be completely sold or the loan paid off after the last payment. If
        omitted, the value is zero.
      </param>
      <param name="payAtEnd">
        If true, payments are made at the end of each period (e.g. for an annuity-immediate), and if false, payments
        are made at the beginning of each period (e.g. for an annuity-due). This affects whether the first and last periods have a chance
        to earn interest. If omitted, the value is true.
      </param>
      <param name="guess">A guess for the result, which must be greater than or equal to -1. If omitted, the value is 0.1 (10%).</param>
      <returns>Returns the interest rate needed to reach the future value over the given number of periods.</returns>
      <example>
        You've been looking for a good investment when a friend asks to borrow $1,000, promising to pay you $50 each month for
        next 21 months (i.e. you'll gain $50 if the loan is repayed). You want to know what APR this is equivalent to, so take payment =
        50 (positive because you're receiving money), paymentCount = 21, presentValue = -1000 (negative because you would pay $1000),
        futureValue = 0 (because the loan will be fully repaid after 21 months), and payAtEnd = true (because the first payment is a month
        away). You get 0.00494, or 0.494% per month. Multiplying by 12 to get the APR, the result is 0.0592, or 5.92% APR.
      </example>
    </Rate>
    <XIRR>
      <summary>Computes the non-periodic, internal rate of return for a series of cash flows.</summary>
      <param name="values">The cash flow values, where negative values are amounts paid and positive values are amounts received. The
        sequence must contain at least one positive and one negative value.
      </param>
      <param name="times">The list of times on which the cash flows occurred, expressed in arbitrary units. The earliest time must come
        first, and the sequence must have the same number of elements as <paramref name="values"/>.
      </param>
      <param name="guess">A guess for the result, which must be greater than or equal to -1. If omitted, the value is 0.1 (10%).</param>
      <returns>Returns the rate that would make the <see cref="PresentValue(double,IEnumerable{double},IEnumerable{double})"/>
        of the investment equal to zero.
      </returns>
    </XIRR>
    <XIRRA>
      <summary>Computes the non-periodic, annualized internal rate of return for a series of cash flows.</summary>
      <param name="values">The cash flow values, where negative values are amounts paid and positive values are amounts received. The
        list must contain at least one positive and one negative value.
      </param>
      <param name="dates">The list of dates on which the cash flows occurred. The earliest date must come first, and the list must have
        the same number of elements as <paramref name="values"/>.
      </param>
      <param name="guess">A guess for the result, which must be greater than or equal to -1. If omitted, the value is 0.1 (10%).</param>
      <returns>Returns the rate that would make the <see cref="PresentValue(double,IEnumerable{double},IEnumerable{DateTime})"/>
        of the investment equal to zero.
      </returns>
      <remarks>This method assumes there are 365.25 days per year.</remarks>
    </XIRRA>
  </Financial>

  <FP107>
    <ExpRemarks>
      <remarks>
        This method cannot always achieve full 107-bit precision, but comes close. The results are more accurate when
        the power is an integer. With integer powers, the relative error ranges from 0 to 4.39e-31. With non-integer powers,
        the relative error ranges from about 0 to 2.8e-30, but is usually at least 5e-33.
      </remarks>
    </ExpRemarks>
    <LogRemarks>
      <remarks>
        This method cannot always achieve full 107-bit precision, although it is close. The relative error is typically around 1e-32, but
        ranges from 0 to 6e-31 through most of the range, and is usually at least 5e-33. With values near the extremes of the range (above
        1e300 or so in magnitude), the relative error may rise to about 5e-27 or more.
      </remarks>
    </LogRemarks>
    <Log10Remarks>
      <remarks>
        This method cannot always achieve full 107-bit precision, although it is close. The relative error is typically around 1e-32, but
        ranges from 0 to 6e-31 through most of the range, and is usually at least 5e-33. With values near the extremes of the range (above
        1e300 or so in magnitude), the relative error may rise to about 5e-27 or more.
        <para>
          This method has a small bias that allows it to produce exact results for powers of 10 from 10^-300 to 10^300, but which
          causes some values very close to powers of 10 to be treated as though they were powers of 10. This bias is small, however; for
          integer values, the first incorrect value to produce the wrong result because of the bias is near 10^29, so the relative error
          introduced by the bias is about 1e-29, and then only for values similarly close to powers of 10.
        </para>
      </remarks>
    </Log10Remarks>
    <Parse>
      <exception cref="ArgumentNullException">Thrown if <paramref name="str"/> is null.</exception>
      <exception cref="FormatException">Thrown if <paramref name="str"/> is not a valid number.</exception>
    </Parse>
    <ParseRemarks>
      <remarks>
        This method cannot parse strings printed using the "S" format.
        <note type="caution">
          This method only guarantees 107 bits of precision on input. As a result, <see cref="FP107"/> values whose effective mantissa is
          larger than 107 bits may not round-trip exactly, even if converted to string using the "R" (round-trip) mode. ("R" only
          guarantees that the first 107 bits will round-trip.) If you want to perfect round-tripping with the built-in parser, use the
          "X" (hexadecimal) mode when converting to string.
        </note>
      </remarks>
    </ParseRemarks>
    <RootRemarks>
      <remarks>
        This method cannot always achieve full 107-bit precision, although it is often close. The relative error is typically around 5e-32, but
        ranges from 5e-33 to 6e-31 through most of the range. With values near the extremes of the range (above 1e300 or so in magnitude) and
        with atypical roots, the relative error may rise to about 1e-25 or more.
        It's more accurate when finding lesser roots (e.g. square root or cube root) than greater roots (e.g. 11th root).
      </remarks>
    </RootRemarks>
    <SinCosRemarks>
      <remarks>
        This method produces the most accurate results when the value ranges from -<see cref="Pi"/> to <see cref="Pi"/>. Outside of that
        range, it will still work, but accuracy will slowly degrade as the magnitude increases.
      </remarks>
    </SinCosRemarks>
    <ToString>
      <remarks>
        This method supports the standard numeric format strings suitable for use with floating point numbers, which are "C", "D", "E",
        "F", "G", "N", "P", and "R", including precision specifiers (such as "F6"). In addition, this method supports the "X" format, which
        is a hexadecimal representation that allows fast, exact conversions to and from string. The method also supports an "S" format
        that returns the individual components, simplifying the creation of constants in source code. (If one component is returned,
        it is an exact double-precision value that can be used to initialize a new <see cref="FP107"/> value. If two components are
        returned, they can be passed to the <see cref="FromComponents"/> method to reconstruct the original value.)
        Custom format strings are not currently supported.
        <note type="caution">
          Although the "R" (round-trip) mode outputs with full precision, the <see cref="FP107.Parse(string)"/> method can only
          guarantee 107 bits of precision on input, so values that have effective mantissas larger than 107 bits will not round-trip if you
          use the built-in parser to parse them, even when using the "R" format string. If you want to guarantee perfect round-tripping
          with the built-in parser, use the "X" (hexadecimal) mode.
        </note>
      </remarks>
    </ToString>
  </FP107>

  <Functions>
    <DifferentiableFunction>
      <DerivativeCount>
        <summary>
          Gets the number of derivatives that are supported by the function. This must be at least one. This is not necessarily
          equal to the number of distinct derivatives. Many functions may support a practically unlimited number of derivatives, but with
          almost all of them equal to zero. The purpose of this property is to allow a method to check that a function supports a given
          number of derivatives, not to allow all of the derivatives to be enumerated.
        </summary>
      </DerivativeCount>
      <EvaluateDerivative>
        <summary>Returns the nth derivative of the function at a the given point.</summary>
        <param name="x">The point at which the derivative is to be evaluated.</param>
        <param name="derivative">
          The derivative to evaluate. The first derivative is specify by passing 1, the second derivative by
          passing 2, etc.
        </param>
        <exception cref="ArgumentOutOfRangeException">
          Thrown if <paramref name="derivative"/> is [ess than 1 or greater than
          <see cref="DerivativeCount"/>.
        </exception>
      </EvaluateDerivative>
      <EvaluateGradient>
        <summary>Returns the gradient (i.e. derivative) of the function at a the given point. This is an array of the same arity of
          the function, where each element is the partial derivative of the function with respect to that parameter.
        </summary>
        <param name="x">The point at which the derivative is to be evaluated.</param>
        <param name="gradient">The array into which the gradient of the function should be stored.</param>
      </EvaluateGradient>
    </DifferentiableFunction>
  </Functions>
  
  <Geometry>
    <Math2D>
      <AngleBetween>
        <summary>This method returns the angle between two points.</summary>
        <param name="start">The first point.</param>
        <param name="end">The second point.</param>
        <returns>
          Returns the angle between <paramref name="start"/> and <paramref name="end"/>, in radians.
          A return value of 0.0 indicates that the second point is to the right of the first point.
        </returns>
      </AngleBetween>
    </Math2D>

    <Line>
     <Line>
      <summary>Initializes this line from a point and a vector.</summary>
      <param name="start">A point on the line (or the start of the line segment).</param>
      <param name="vector">The line's direction. If you're defining a line segment, this should be the distance
      travelled from <paramref name="start"/>.
      </param>
     </Line>
     <Line2>
      <summary>Initializes this line from two points.</summary>
      <param name="start">A point on the line (or the start of the line segment).</param>
      <param name="end">Another point on the line (or the end of the line segment).</param>
      <remarks>Since the end point will need to be converted into a vector, some miniscule accuracy may be lost.
      Most notably, the <see cref="End"/> property may not be exactly equal to <paramref name="end"/>.
      </remarks>
     </Line2>
     <GetPoint>
      <summary>Gets one of the endpoints of the line segment.</summary>
      <param name="point">The index of the point to retrieve. A value of zero indicates that the start point should
      be returned, and a value of 1 indicates that the endpoint should be returned.
      </param>
      <returns>The requested point.</returns>
      <remarks>This method simply returns <see cref="Start"/> or <see cref="End"/> depending on the value of
      <paramref name="point"/>.
      </remarks>
      <exception cref="ArgumentOutOfRangeException">Thrown if <paramref name="point"/> is not 0 or 1.</exception>
     </GetPoint>
     <Equals>
      <summary>Determines whether the given object is a line exactly equal to this one.</summary>
      <param name="obj">An object to test for equality.</param>
      <returns>Returns true if <paramref name="obj"/> is a line and equals this one.</returns>
     </Equals>
     <Equals>
      <summary>Determines whether the given line exactly equal to this one.</summary>
     </Equals>
     <Equals3>
      <summary>Determines whether the given line is equal to this one, within a given margin of error.</summary>
      <param name="line">A line to test for equality.</param>
      <param name="epsilon">The given margin of error. The difference between both lines' <see cref="Start"/> and
      <see cref="Vector"/> properties must be less than or equal to this for them to qualify as equal.
      </param>
      <returns>Returns true if <paramref name="line"/> equals this line, within the given margin of error.</returns>
     </Equals3>
    </Line>

    <Point>
     <DistanceTo>
      <summary>Calculates the distance to another point.</summary>
      <param name="point">The point to calculate the distance to.</param>
      <returns>The distance to <paramref name="point"/>.</returns>
     </DistanceTo>
     <DistanceSquaredTo>
      <summary>Calculates the square of the distance to another point.</summary>
      <param name="point">The point to calculate the distance to.</param>
      <returns>The distance to <paramref name="point"/>, squared.</returns>
     </DistanceSquaredTo>
     <Equals>
      <summary>Determines whether the given object is a point equal to this one.</summary>
      <param name="obj">An object to test for equality.</param>
      <returns>Returns true if <paramref name="obj"/> is a point and equals this one.</returns>
     </Equals>
     <Equals3>
      <summary>Determines whether the given point is equal to this one, within a given margin of error.</summary>
      <param name="point">A point to test for equality.</param>
      <param name="epsilon">The given margin of error. The difference between both points' X and Y coordinates must be
      less than or equal to this for them to qualify as equal.
      </param>
      <returns>Returns true if <paramref name="point"/> equals this point, within the given margin of error.</returns>
     </Equals3>
    </Point>

    <Vector>
     <DotProduct>
      <summary>Returns the dot product of this vector with another vector.</summary>
      <param name="v">The other operand for the dot product operation.</param>
      <returns>The dot product, which is the cosine of the angle between the two vectors, scaled by the magnitudes
      of both vectors.
      </returns>
     </DotProduct>
     <Equals>
      <summary>Determines whether the given object is a vector exactly equal to this one.</summary>
      <param name="obj">An object to test for equality.</param>
      <returns>Returns true if <paramref name="obj"/> is a vector and equals this one.</returns>
     </Equals>
     <Equals>
      <summary>Determines whether the given vector is exactly equal to this one.</summary>
     </Equals>
     <Equals3>
      <summary>Determines whether the given vector is equal to this one, within a given margin of error.</summary>
      <param name="vect">A vector to test for equality.</param>
      <param name="epsilon">The given margin of error. The difference between both vectors' X and Y axes must be
      less than or equal to this for them to qualify as equal.
      </param>
      <returns>Returns true if <paramref name="vect"/> equals this one, within the given margin of error.</returns>
     </Equals3>
     <Normalize>
      <summary>Normalizes this vector to a length of 1.</summary>
      <remarks>Calling this method is invalid when the length of the vector is zero, since the vector would not be
      pointing in any direction and could not possibly be scaled to the correct length.
      </remarks>
     </Normalize>
     <Normalize2>
      <summary>Normalizes this vector to a given length.</summary>
      <param name="length">The desired length of the vector.</param>
      <remarks>Calling this method is invalid when the length of the vector is zero, since the vector would not be
      pointing in any direction and could not possibly be scaled to the given length.
      </remarks>
     </Normalize2>
     <Length>
      <summary>Calculates and returns the length of this vector, or sets the length.</summary>
      <remarks>Setting this property is not valid when the length of the vector is already zero, since the vector
      would not be pointing in any direction and could not possibly be scaled up to the given length.
      </remarks>
     </Length>
     <Normal>
      <summary>Returns a normalized copy of this vector.</summary>
      <value>A vector pointing in the same direction as this one, but with a length of 1.0 (or as
      close as floating-point precision will let us get to 1.0).
      </value>
      <remarks>This property is not valid when the length of the vector is zero, since the vector would not be
      pointing in any direction and could not possibly be scaled to the correct length.
      </remarks>
     </Normal>
    </Vector>
  </Geometry>

  <Integer>
    <BitwiseOps>
      <remarks>
        <note type="caution">
          This method performs a bitwise operation. This works as expected for positive operands, however negative operands are different.
          In normal fixed-size integers (such as int and long) negative values are stored in two's complement form on most machines. This
          means that <c>-x == ~((unsigned)x-1)</c>. Two's complement form is one way to conveniently represent positive and negative
          numbers in a fixed-size integer on a CPU. For an arbitrarily sized integer type such as this, two's complement is unnecessary.
          However, bitwise operations depend on the precise bits stored in the value, so for consistency with fixed-size integers this
          method will emulate two's complement for negative values. This may result in a substantial performance decrease and an unexpected
          result. If you wish to avoid this behavior, only perform bitwise operations on non-negative integers.
        </note>
      </remarks>
    </BitwiseOps>
    <UnsafeOps>
      <remarks>
        <note type="caution">
          This method is unsafe. <see cref="Integer"/> values can share storage with each other. Operations between two Integers may result
          in new Integer that shares storage with one or both of the operands. For instance, <c>a = b</c> or <c>a | b</c> or
          <c>a &amp; b</c> or <c>a + b</c> or others may result in a new value that shares internal storage with <c>a</c> or <c>b</c>, even
          if the result doesn't have the same value as either <c>a</c> or <c>b</c>. (Storage may be shared if they have the same magnitude,
          regardless of sign.) Since Integer values are immutable for all normal operations, this improves performance. However, if an
          unsafe method is invoked, it may mutate the integer in-place without allocating new storage. This can greatly improve performance
          in some cases, but if the integer shares storage with other values, the other values may become corrupted.
          <para>
            To use unsafe methods properly, first make sure that the integer does not share storage with other values. You can do this by
            not setting the value based on other <see cref="Integer"/> values and not setting other values based on it. For instance, it's
            safe to perform unsafe operations on an Integer initialized from a non-Integer value such as an int literal. As an exception,
            it's also safe to perform unsafe operations on values initialized using <see cref="One"/>, <see cref="MinusOne"/>, or
            <see cref="Zero"/>. Alternately, you can call <see cref="Clone"/> to obtain an Integer that is guaranteed not to share storage
            with any other values. Just be careful not to reintroduce sharing, as in the following:
            <c>a = a.Clone(); a.UnsafeIncrement(); ... b *= a; ... a.UnsafeIncrement();</c> In the example, <c>a</c> is cloned, allowing
            unsafe operations upon it. But then it is used to reassign <c>b</c>, potentially causing <c>b</c> to share storage with
            <c>a</c>. Then a later unsafe operation upon <c>a</c> can corrupt <c>b</c>. If you really want to walk a fine line, you can mix
            unsafe operations with normal operations as long as you can guarantee that the normal operations do not cause sharing, i.e.
            that the result will not have a magnitude equal to any operand. In the example above, <c>b *= a</c> would be safe if you know
            that neither operand equals 1 or -1. (Zero values never share internal storage.)
          </para>
          <para>Finally, don't assume unsafe operations always do the operation in-place. Sometimes they have to allocate new storage.</para>
        </note>
      </remarks>
    </UnsafeOps>
  </Integer>

  <LinearAlgebra>
    <ILinearEquationSolver>
      <GetInverse>
        <summary>Returns the inverse of the coefficient matrix.</summary>
      </GetInverse>
      <Initialize>
        <summary>Initializes the solver with the given coefficient matrix.</summary>
        <param name="coefficients">
          A square matrix representing the left side of the equations, where the rows represent the individual
          equations and the columns represent the coefficients in the equations. The matrix must be invertible.
        </param>
      </Initialize>
      <Solve>
        <summary>Solves the system of linear equations using the given right-hand side values.</summary>
        <include file="documentation.xml" path="/Math/LinearEquations/Solve/*[not(@name='inverse')]"/>
      </Solve>
      <Solve1>
        <summary>Solves the system of linear equations using the given right-hand side values.</summary>
        <include file="documentation.xml" path="/Math/LinearEquations/Solve/*[not(@name='inverse') and not(@name='inPlace')]"/>
      </Solve1>
    </ILinearEquationSolver>

    <QRDecomposition>
      <Update>
        <summary>Updates the QR decomposition to represent a new, related set of linear equations.</summary>
        <remarks>
          A special property of the QR decomposition is that the coefficient matrix A can be efficiently updated to a new
          coefficient matrix equal to A + (s ⊗ t) where s and t are vectors and ⊗ is the tensor product. (This is related to the
          Sherman-Morrison formula for updating the matrix inverse of a matrix M given an update to M of the form M = M + (a ⊗ b).)
          This method performs that update indirectly. Given that A = Q*R, we have A + (s ⊗ t) = Q*(R + (u ⊗ v)), where t = v and
          s = Q*u (or u = transpose(Q)*s).
        </remarks>
      </Update>
    </QRDecomposition>

    <Solve>
      <param name="coefficients">A square matrix representing the left side of the equations, where the rows represent the individual
        equations and the columns represent the coefficients in the equations. The matrix must be invertible.
      </param>
      <param name="values">A matrix of the same height as <paramref name="coefficients"/> representing the right side of the
        equations, where each column contains the set of sums of the equation terms (i.e. what the equation equals).
      </param>
      <param name="inverse">A variable that receives the inverse of the <paramref name="coefficients" /> matrix.</param>
      <param name="tryInPlace">If true, the values matrix will be updated in place to become the solution matrix, if possible. If false, a
        new solution matrix will always be allocated. Note that in-place solution is not always possible, so you should always take the
        return value as the answer rather than assuming that the solution was done in place.
      </param>
      <returns>
        A matrix of the same size as <paramref name="values" /> where each column contains a solution to the system of equations (using
        the values from the corresponding column in <paramref name="values" />), and each row represents a variable.
      </returns>
      <remarks>
        As an example, to solve the following set of equations:
        <code>
          4x + 2y - 2z = 10
          2x + 8y + 4z = 32
          30x + 12y - 4z = 24
        </code>
        You would construct the following coefficients matrix:
        <code>
           4  2 -2
           2  8  4
          30 12 -4
        </code>
        And the following values matrix:
        <code>
          10
          32
          24
        </code>
        The method would return a matrix containing the solution:
        <code>
          -2
           6
          -3
        </code>
      </remarks>
    </Solve>

    <SVDecomposition>
      <GeneralRemarks>
        <remarks>
          <para>
            An MxN matrix A transforms an N-dimensional vector into an M-dimensional vector. That is, it represents a transformation
            from N-dimensional space to M-dimensional space. However, sometimes the transformation only maps to a subspace of M. This is
            always true, for instance, when N &lt; M. Singular value decomposition decomposes A into two column-orthogonal matrices,
            commonly denoted U and V (each of width N), a subset of whose columns represent orthonormal basis vectors of the range and null
            space of the matrix, respectively. The range of A describes the subspace of M-dimensional space mapped to by the
            transformation, while the null space describes the subset of N-dimensional space that is mapped to zero in M-dimensional space.
            The dimension of A's range is known as A's rank, and the dimension of A's null space is known as A's nullity.
          </para>
          <para>
            In addition to U and V, singular value decomposition produces the singular values of A. (Technically, the singular values are
            the square roots of the eigenvalues of transpose(A) * A, and also of A * transpose(A).) Geometrically, the matrix A transforms an
            N-dimensional unit sphere into an M-dimensional ellipsoid, and the non-zero singular values are the lengths of the ellipsoid's
            semi-axes. Practically, singular values are rarely exactly zero with numerical methods, given roundoff error, so we treat very
            small singular values (less than a given fraction of the largest singular value) as though they were zero.
          </para>
          <para>
            The singular values provide a number of things. First, they determine which columns of U and V are part of the matrix's range
            and null space, respectively. Columns in U whose corresponding singular value is non-zero (in practice, above a threshold) form the
            basis of the range, while columns in V whose corresponding singular values are zero (in practice, very small) form the basis of the
            null space.
            The singular values also provide a measure of how singular a matrix is. The so-called condition number of a matrix is the ratio of
            the largest singular value to the smallest. If infinite (i.e. if a singular value is zero), the matrix is singular (degenerate).
            If very large, the matrix is ill-conditioned. The condition number roughly corresponds to how much the solution to the matrix
            changes with a change in right-hand side values, so with a large condition number, a small error in right-hand side values will
            become a large error in the solution. Also, roundoff error can be multiplied by the condition number.
          </para>
          <para>
            If the vector of singular values is named <c>w</c>, then <c>A = U * diag(w) * transpose(V)</c>.
          </para>
        </remarks>
      </GeneralRemarks>
      <NullSpaceRemarks>
        <remarks>
          As mentioned above, the null space of a matrix represents the subset of N-dimensional space that is mapped to zero in
          M-dimensional space, and the nullity of a matrix is the dimension of its null space.
          If a matrix representing a set of linear equations has a unique solution, then the null space contains only
          the zero vector. That is to say that only the zero vector in N-space becomes a zero vector in M-space. In general, the set of
          solutions can be found using the description of the space returned from <see cref="GetNullSpace" />. The set of solutions is
          any solution vector plus any linear combination of the column vectors of the null space. You can use <see cref="Solve" /> to
          retrieve an initial solution vector from which the other solutions can be generated. (If the null space is empty, then that
          solution is unique.)
        </remarks>
      </NullSpaceRemarks>
      <RangeRemarks>
        <remarks>
          As mentioned above, the range of a matrix represents the subset of M-dimensional space that is mapped to by the transformation
          represented by the matrix, and the rank of a matrix is the dimension of its range.
          The range of the decomposed matrix is set of M-dimensional points (vectors) formed by the addition of
          any linear combination of the column vectors of the matrix returned by <see cref="GetRange" />.
        </remarks>
      </RangeRemarks>
      <SolveRemarks>
        <remarks>
          When using singular value decomposition to solve a system of linear equations, there are three main cases to consider. First,
          when the linear system has a single solution, single value decomposition (SVD) will find it. When the system has no solution, SVD
          will produce the closest vector to a solution in the least squares sense. When the system has an infinite number of solutions,
          SVD will produce the smallest solution vector, which can be used with <see cref="GetNullSpace"/> to generate any of the other
          solutions. This implementation of SVD can only do in-place solving when the solution matrix has the same height as the width of
          the decomposed matrix, or the solution matrix has a width of 1. In other situations, it will return a new matrix, even if you
          requested in-place solving.
        </remarks>
      </SolveRemarks>
    </SVDecomposition>
  </LinearAlgebra>

  <Optimization>
    <ConstrainedMinimizer>
      <OOBRemarks>
        <remarks>
          Note that if <see cref="ConstraintEnforcement"/> is set to a penalty method, the objective function may be invoked with
          parameter values that don't satisfy the constraints. It should not throw an exception in that case. If possible, the behavior of
          the function outside the bounds of the constraints should be smooth, to allow the search to easily traverse the topography of the
          function back into the feasible region. However, if the objective function is meaningless outside its bounds, an appropriate
          behavior is to return <see cref="double.NaN"/> and/or to set <see cref="ConstraintEnforcement"/> to use a barrier method rather
          than a penalty method.
        </remarks>
      </OOBRemarks>
    </ConstrainedMinimizer>
    <Minimize>
      <BGFS>
        <param name="function">The function to evaluate.</param>
        <param name="x">
          The initial point at which the function will be evaluated. The value of the function parameter at the minimum point
          will be stored here.
        </param>
        <param name="tolerance">
          The error tolerance to which the minimum will be found. Specifically, the function's gradient will be
          reduced until it is below the tolerance.
        </param>
        <returns>Returns the value of the function at the minimum point.</returns>
        <remarks>This method implements the Broyden-Fletcher-Goldfarb-Shanno (BFGS) quasi-Newton algorithm for multidimensional
          minimization. Although it expects a differentiable multidimensional function, if you cannot calculate a gradient for your
          function, it is possible in many cases to approximate it using <see cref="ApproximatelyDifferentiableMDFunction" />.
        </remarks>
      </BGFS>
      <BracketInward>
        <summary>Attempts to enumerate brackets containing local minima within an interval of a function.</summary>
        <param name="function">The function to be evaluated.</param>
        <param name="x1">The first point bounding the interval to search within.</param>
        <param name="x2">The second point bounding the interval to search within.</param>
        <param name="segments">The number of subintervals into which the interval will be divided when looking for minima.</param>
        <remarks>
          This method works by dividing the interval into a number of equal-sized subintervals. Within each subinterval, it takes the
          function value at the two edges and at the midpoint. If the midpoint is lower than the edges, then the subinterval brackets a
          minimum and is returned. Otherwise, the method assumes that the function's local behavior can be approximated by a quadratic
          form, fits a parabola to the three known points, and examines the function's value at the minimum of the parabola. Again, if the
          function's value there is less than the edges, then the subinterval brackets a minimum and is returned. This method may fail if
          the local behavior of the function within the subinterval cannot be approximated well by a quadratic form. For well-behaved
          functions, using smaller subintervals (by increasing the number of segments) can usually give better results.
        </remarks>
      </BracketInward>
      <BracketOutward>
        <summary>Given an initial guess of an interval containing a local minimum, expands the interval outward until a minimum is found.</summary>
        <param name="function">The function to evaluate.</param>
        <param name="x1">The first point bounding the interval of the initial guess.</param>
        <param name="x2">The second point bounding the interval of the initial guess.</param>
        <param name="bracket">A variable that is set to the bracket containing a minimum, if one is found.</param>
        <returns>Returns true if an interval containing a local minimum was found, or false if no interval was found.</returns>
        <remarks>
          This method identifies a local minimum by searching for three points where the middle point is less than or equal to the
          both edge points, but if the function values at the initial points are not equal, a minimum with all three points equal will not
          be returned. The method is not guaranteed to find minima in all cases where they exist, but for well-behaved functions it should
          be quite robust.
        </remarks>
      </BracketOutward>
      <DBrentRemarks>
        <remarks>
          This method implements Brent's method for minimization of differentiable one-dimensional functions, which is the
          recommended method.
        </remarks>
      </DBrentRemarks>
      <NDBrentRemarks>
        <remarks>
          This method implements Brent's method for minimization of general one-dimensional functions. Brent's method is the recommended
          method for one-dimensional function minimization, but if you can efficiently calculate the derivative of your function, it is
          better to use an override that takes an <see cref="IDifferentiableFunction"/> rather than this general version, which does not
          make use of derivative information.
        </remarks>
      </NDBrentRemarks>
      <GoldenSectionRemarks>
        <remarks>
          This method implements golden section search, which is a method for one-dimensional function minimization that is simple and
          highly robust, but fairly slow. It is better in almost all cases to use <see cref="Brent" />.
        </remarks>
      </GoldenSectionRemarks>
      <Minimize1D>
        <summary>Finds a local minimum of a one-dimensional function within the given bracket.</summary>
        <param name="function">The function to evaluate.</param>
        <param name="bracket">
          A <see cref="MinimumBracket"/> that is assumed to bracket a local minimum.
        </param>
        <param name="tolerance">
          The desired fractional tolerance. The location of the minimum will be found approximately plus or minus an
          error equal the tolerance value times the location of the minimum. The should be greater than or equal to
          <see cref="IEEE754.SqrtDoublePrecision" />, as roundoff error prevents the achievement of any better accuracy.
        </param>
        <param name="value">A variable that will receive the value of the function at the minimum.</param>
        <returns>Returns the value of the function's argument that produces a minimum within the given bracket.</returns>
        <exception cref="MinimumNotFoundException">Thrown if no minimum was found within the bracket.</exception>
      </Minimize1D>
    </Minimize>
  </Optimization>

  <Rational>
    <UnsimplifiedRemarks>
      <remarks>
        Normally, rational arithmetic simplifies the result to obtain a canonical form. This avoids exponential growth in the
        sizes of the numerator and denominator, but the simplification step is quite slow, usually taking as much time as quite a few
        arithmetic operations. Some algorithms can gain a significant performance boost by delaying simplification until the end, or only
        performing it periodically. You can manually simplify a rational by calling <see cref="Simplify()"/>.
        <note type="caution">
          Many internal algorithms assume that the rational value is simplified. In particular, comparison functions
          (such as <see cref="Equals(Rational)"/>), operators (such as &lt; or &gt;), and properties (such as <see cref="IsInteger"/>) will
          fail, among others (although you can use <see cref="UnsimplifiedCompare"/>). Some properties and methods guaranteed to be safe
          are: <see cref="IsPositive"/>, <see cref="IsNegative"/>, <see cref="IsZero"/>, <see cref="Sign"/>, <see cref="Abs()"/>,
          <see cref="Inverse()"/>, <see cref="Round()"/>, <see cref="Simplify()"/>, <see cref="ToContinuedFraction"/>,
          <see cref="ToString()"/> <see cref="Truncate()"/>, and all methods whose name starts with "Unsimplified" (such as this method).
        </note>
      </remarks>
    </UnsimplifiedRemarks>
  </Rational>

  <ReedSolomon>
    <Check>
      <summary>Checks whether a data block is probably uncorrupted.</summary>
      <param name="source">The array containing the data block, in the form returned by <see cref="Encode(byte[],int,int,byte[],int)"/></param>
      <param name="srcIndex">The index within <paramref name="source"/> at which the data block begins</param>
      <param name="length">The length of the encoded data block, including the error-correction symbols</param>
      <returns>
        Returns true if the data block is probably uncorrupted, and false if it is definitely corrupted. A return value of false
        does not necessarily imply that the data cannot be corrected by the Reed-Solomon code, only that corrections are needed. A return
        value of true does not guarantee that the original data can be recovered, but it is very likely. (It is possible but very unlikely
        that a block can be corrupted in just the right way so that it looks like a different, valid block from the original.)
      </returns>
    </Check>
    <DecodeInt>
      <summary>Decodes a data block, correcting any errors if possible.</summary>
      <param name="source">The data block to decode</param>
      <param name="srcIndex">The index within <paramref name="source"/> at which the data block begins</param>
      <param name="length">The length of the encoded data block, including the error-correction symbols</param>
      <param name="destination">The destination array where the original data will be written</param>
      <param name="destIndex">The index within <paramref name="destination"/> at which the data block will be written</param>
      <param name="errorPositions">
        An array containing the indexes within <paramref name="source"/> containing errors, relative to the
        beginning of the data block, or null if the locations of errors are not known. Not all error locations must be provided, but the
        more are provided, the more errors can be corrected. For example, if the second byte is in error, you would pass a position of 1,
        not a position of <paramref name="srcIndex"/>+1.
      </param>
      <param name="allErrorsKnown">
        If true, all error locations are assumed to be known and passed within <paramref name="errorPositions"/>. This speeds up the
        decoding, because the error locations do not need to be found, but if additional errors exist they may not be detected.
        If false, a search step will be used to find the error locations, which can find errors in addition to those provided in
        <paramref name="errorPositions"/>. The default is false.
      </param>
      <returns>
        Returns the number of bytes decoded if the data was decoded successfully, or -1 if the data was not decoded successfully. If
        decoding was successful, the number of bytes decoded will equal <paramref name="length"/>-<see cref="EccLength"/>.
      </returns>
      <remarks>
        This method can correct up to <see cref="EccLength"/>/2 errors. If the locations of errors are known, you can correct up
        to <see cref="EccLength"/> errors by using the <see cref="Decode(byte[],int,int,byte[],int,int[],bool)"/> method instead. A true
        return value does not guarantee that the original data has been recovered, only that the data block does not appear corrupted. (It
        is possible, albeit very unlikely, that a data block is corrupted into a different but valid data block.)
      </remarks>
    </DecodeInt>
    <DecodeBytes>
      <summary>Decodes a data block, correcting any errors if possible, and returns the decoded data.</summary>
      <param name="source">The data block to decode</param>
      <param name="srcIndex">The index within <paramref name="source"/> at which the data block begins</param>
      <param name="length">The length of the encoded data block, including the error-correction symbols</param>
      <param name="errorPositions">
        An array containing the indexes within <paramref name="source"/> containing errors, relative to the
        beginning of the data block, or null if the locations of errors are not known. Not all error locations must be provided, but the
        more are provided, the more errors can be corrected. For example, if the second byte is in error, you would pass a position of 1,
        not a position of <paramref name="srcIndex"/>+1.
      </param>
      <param name="allErrorsKnown">
        If true, all error locations are assumed to be known and passed within <paramref name="errorPositions"/>. This speeds up the
        decoding, because the error locations do not need to be found, but if additional errors exist they may not be detected.
        If false, a search step will be used to find the error locations, which can find errors in addition to those provided in
        <paramref name="errorPositions"/>. The default is false.
      </param>
      <returns>Returns the decoded data from the data block, or null if the data block could not be decoded.</returns>
      <remarks>
        This method can correct up to <see cref="EccLength"/>/2 errors if no error locations are known, or up to
        <see cref="EccLength"/> errors if all error locations are known, or some number in between if some error locations are known.
        A non-null return value does not guarantee that the original data has been recovered, only that the data block does not appear
        corrupted. (It is possible, albeit very unlikely, that a data block is corrupted into a different but valid data block.)
      </remarks>
    </DecodeBytes>
  </ReedSolomon>
  
  <RNG>
    <SeedSize>
      <summary>The number of uints that should be used to used to seed the random number generator.</summary>
    </SeedSize>
    <LoadStateCore>
      <summary>Loads the state of the generator, as implemented by derived classes, from a <see cref="BinaryReader" />.</summary>
    </LoadStateCore>
    <SaveStateCore>
      <summary>Saves the state of the generator, as implemented by derived classes, to a <see cref="BinaryWriter" />.</summary>
    </SaveStateCore>
    <NextUint32>
      <summary>Generates and returns a random 32-bit unsigned integer.</summary>
    </NextUint32>
  </RNG>

  <RootFinding>
    <BoundedNewtonRaphson>
      <remarks>
        This function converges quadratically on the root, making it a very effective method. It also tends to be quite accurate.
        However, it is vulnerable to pathological cases in which it can fail to find a root even when it exists. Newton-Raphson is also
        quite sensitive in requiring the initial guess to be fairly close to the root. In difficult cases, it may be better to use
        <see cref="Brent">Brent's method</see>, or even the <see cref="Subdivide">the subdivision method</see>. This implementation of
        Newton's method brackets the root within an interval to avoid shortcomings in the standard Newton's method that cause it to diverge
        wildly if it encounters a derivative near zero. Because of the bracketing, the method generally cannot find double roots. If you
        need to find a double root, you may try <see cref="UnboundedNewtonRaphson" />.
      </remarks>
    </BoundedNewtonRaphson>

    <BracketInward>
      <summary>
        Given an initial guess of an interval containing a root, divides the interval into a number of subintervals and enumerates the
        subintervals that contain zero crossings, which usually indicate the existence of roots.
      </summary>
      <param name="function">The function to evaluate.</param>
      <param name="interval">
        An initial guess of an interval of parameter values for which the function contains a root (i.e. evaluates
        to zero).
      </param>
      <param name="segments">
        The number of equal-sized segments into which the interval should be divided when searching for subintervals
        that contain zero crossings.
      </param>
      <remarks>
        This method doesn't necessarily find roots. It merely looks for zero crossings, which usually indicate a root but could also
        indicate a singularity or discontinuity. Also, roots that don't cross zero, such as double roots, are unlikely to be found by this
        method, but if found, could be returned in two different intervals (at their edges).
      </remarks>
    </BracketInward>

    <BracketOutward>
      <summary>
        Given an initial guess of an interval containing a root, expands the interval outward until the function values at the two
        edges cross zero (i.e. have different sign). This usually indicates a root.
      </summary>
      <param name="function">The function to evaluate.</param>
      <param name="initialGuess">
        An initial guess of an interval of parameter values for which the function contains a root (i.e.
        evaluates to zero).
      </param>
      <returns>Returns true if an interval was found for which the function values cross zero, or false if no interval was found.</returns>
      <remarks>
        This method doesn't necessarily find roots. It merely looks for zero crossings, which usually indicate a root but could also
        indicate a singularity or discontinuity. Also, roots that don't cross zero, such as double roots, are unlikely to be found by this
        method.
      </remarks>
    </BracketOutward>

    <Brent>
      <remarks>
        This function converges quadratically on the root, making it a very effective method, although if you can efficiently calculate the
        derivative of the function, it might be better to use <see cref="BoundedNewtonRaphson">the Newton-Raphson</see> method.
        Newton-Raphson tends to find the root more quickly and accurately, but is vulnerable to pathological cases in which it can fail to
        find a root even when it exists. Newton-Raphson may also be more sensitive in requiring the initial guess to be close to the root.
      </remarks>
    </Brent>
    
    <FindRoot1>
      <summary>Implements the subdivision method of finding a root of a one-dimensional function.</summary>
      <param name="function">The function to evaluate.</param>
      <param name="interval">
        An interval in which a root has been bracketed. If the interval does not contain a root, the method will
        produce the wrong result.
      </param>
      <param name="tolerance">
        The error tolerance to which the root will be found. The root will be refined until it is within the given distance of the
        true root.
      </param>
      <returns>Returns a root of the function, to within the specified tolerance. See the remarks for more details.</returns>
      <exception cref="ArgumentException">Thrown if the interval is invalid, the interval does not bracket a zero crossing, or the function
        cannot find a zero crossing within the given interval to the desired tolerance.
      </exception>
      <remarks>
        Specifically, this function homes in on the point at the function changes sign. This usually indicates a root, but it could
        also indicate a singularity or discontinuity. Therefore, if the interval brackets one of these rather than a root, the function
        will locate the singularity or discontinuity instead.
      </remarks>
    </FindRoot1>

    <UnboundedNewtonRaphson>
      <remarks>This function converges quadratically on the root, making it a very effective method. It also tends to be quite accurate.
        However, it is vulnerable to pathological cases in which it can fail to find a root even when it exists. Newton-Raphson is also
        quite sensitive in requiring the initial guess to be fairly close to the root. This implementation of Newton's method does not
        bracket the root and may diverge wildly. In general, it is better to use <see cref="BoundedNewtonRaphson" />, but that method
        usually cannot be used to find double roots, while this one can.
      </remarks>
    </UnboundedNewtonRaphson>

    <Subdivide>
      <remarks>
        This function converges linearly on the root, which makes it rather slow compared to other methods such as
        <see cref="Brent">Brent's method</see> and <see cref="BoundedNewtonRaphson">the Newton-Raphson method</see>, but it is very simple
        and reliable, and a good method to try as a last resort.
      </remarks>
    </Subdivide>
  </RootFinding>
</Math>
