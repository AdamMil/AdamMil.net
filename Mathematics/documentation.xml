<?xml version="1.0" encoding="utf-8" ?>
<Math>
  <CoherentNoise>
    <AboutPerlin>
      <remarks>
        Perlin noise is a coherent, pseudo-random noise source developed by Ken Perlin in the 1980s. It won him an
        academy award, as the technique quickly became ubiquitous in the generation of all kinds of procedural textures
        for use in computer graphics. Perlin noise has some minor flaws, however. These include computational
        complexity that increases exponentially with the number of dimensions and minor directional artifacts due to
        its anisotropy. These have been mostly rectified by the creation of Simplex noise, which is also implemented
        in this class. Note that this class implements the improvements to Perlin noise that Ken Perlin published in
        2002, which eliminate several artifacts.
      </remarks>
    </AboutPerlin>

    <AboutSimplex>
      <remarks>
        Simplex noise is a coherent, pseudo-random noise source developed by Ken Perlin in 2001 to address the flaws in
        his earlier Perlin noise algorithm. Simplex noise is substantially faster than Perlin noise above 3 dimensions,
        is visually isotropic, and is easy to implement in hardware. It can be used for the same tasks to which Perlin
        noise is typically applied.
      </remarks>
    </AboutSimplex>
  </CoherentNoise>

  <Common>
    <GetHashCode>Returns a hash code for the object.</GetHashCode>
  </Common>

  <Geometry>
    <Math2D>
      <AngleBetween>
        <summary>This method returns the angle between two points.</summary>
        <param name="start">The first point.</param>
        <param name="end">The second point.</param>
        <returns>
          Returns the angle between <paramref name="start"/> and <paramref name="end"/>, in radians.
          A return value of 0.0 indicates that the second point is to the right of the first point.
        </returns>
      </AngleBetween>
    </Math2D>

    <Line>
     <Line>
      <summary>Initializes this line from a point and a vector.</summary>
      <param name="start">A point on the line (or the start of the line segment).</param>
      <param name="vector">The line's direction. If you're defining a line segment, this should be the distance
      travelled from <paramref name="start"/>.
      </param>
     </Line>
     <Line2>
      <summary>Initializes this line from two points.</summary>
      <param name="start">A point on the line (or the start of the line segment).</param>
      <param name="end">Another point on the line (or the end of the line segment).</param>
      <remarks>Since the end point will need to be converted into a vector, some miniscule accuracy may be lost.
      Most notably, the <see cref="End"/> property may not be exactly equal to <paramref name="end"/>.
      </remarks>
     </Line2>
     <GetPoint>
      <summary>Gets one of the endpoints of the line segment.</summary>
      <param name="point">The index of the point to retrieve. A value of zero indicates that the start point should
      be returned, and a value of 1 indicates that the endpoint should be returned.
      </param>
      <returns>The requested point.</returns>
      <remarks>This method simply returns <see cref="Start"/> or <see cref="End"/> depending on the value of
      <paramref name="point"/>.
      </remarks>
      <exception cref="ArgumentOutOfRangeException">Thrown if <paramref name="point"/> is not 0 or 1.</exception>
     </GetPoint>
     <Equals>
      <summary>Determines whether the given object is a line equal to this one.</summary>
      <param name="obj">An object to test for equality.</param>
      <returns>Returns true if <paramref name="obj"/> is a line and equals this one.</returns>
     </Equals>
     <Equals3>
      <summary>Determines whether the given line is equal to this one, within a given margin of error.</summary>
      <param name="line">A line to test for equality.</param>
      <param name="epsilon">The given margin of error. The difference between both lines' <see cref="Start"/> and
      <see cref="Vector"/> properties must be less than or equal to this for them to qualify as equal.
      </param>
      <returns>Returns true if <paramref name="line"/> equals this line, within the given margin of error.</returns>
     </Equals3>
    </Line>

    <Point>
     <DistanceTo>
      <summary>Calculates the distance to another point.</summary>
      <param name="point">The point to calculate the distance to.</param>
      <returns>The distance to <paramref name="point"/>.</returns>
     </DistanceTo>
     <DistanceSquaredTo>
      <summary>Calculates the square of the distance to another point.</summary>
      <param name="point">The point to calculate the distance to.</param>
      <returns>The distance to <paramref name="point"/>, squared.</returns>
     </DistanceSquaredTo>
     <Equals>
      <summary>Determines whether the given object is a point equal to this one.</summary>
      <param name="obj">An object to test for equality.</param>
      <returns>Returns true if <paramref name="obj"/> is a point and equals this one.</returns>
     </Equals>
     <Equals3>
      <summary>Determines whether the given point is equal to this one, within a given margin of error.</summary>
      <param name="point">A point to test for equality.</param>
      <param name="epsilon">The given margin of error. The difference between both points' X and Y coordinates must be
      less than or equal to this for them to qualify as equal.
      </param>
      <returns>Returns true if <paramref name="point"/> equals this point, within the given margin of error.</returns>
     </Equals3>
    </Point>

    <Vector>
     <DotProduct>
      <summary>Returns the dot product of this vector with another vector.</summary>
      <param name="v">The other operand for the dot product operation.</param>
      <returns>The dot product, which is the cosine of the angle between the two vectors, scaled by the magnitudes
      of both vectors.
      </returns>
     </DotProduct>
     <Equals>
      <summary>Determines whether the given object is a vector equal to this one.</summary>
      <param name="obj">An object to test for equality.</param>
      <returns>Returns true if <paramref name="obj"/> is a vector and equals this one.</returns>
     </Equals>
     <Equals3>
      <summary>Determines whether the given vector is equal to this one, within a given margin of error.</summary>
      <param name="vect">A vector to test for equality.</param>
      <param name="epsilon">The given margin of error. The difference between both vectors' X and Y axes must be
      less than or equal to this for them to qualify as equal.
      </param>
      <returns>Returns true if <paramref name="vect"/> equals this one, within the given margin of error.</returns>
     </Equals3>
     <Normalize>
      <summary>Normalizes this vector to a length of 1.</summary>
      <remarks>Calling this method is invalid when the length of the vector is zero, since the vector would not be
      pointing in any direction and could not possibly be scaled to the correct length.
      </remarks>
     </Normalize>
     <Normalize2>
      <summary>Normalizes this vector to a given length.</summary>
      <param name="length">The desired length of the vector.</param>
      <remarks>Calling this method is invalid when the length of the vector is zero, since the vector would not be
      pointing in any direction and could not possibly be scaled to the given length.
      </remarks>
     </Normalize2>
     <Length>
      <summary>Calculates and returns the length of this vector, or sets the length.</summary>
      <remarks>Setting this property is not valid when the length of the vector is already zero, since the vector
      would not be pointing in any direction and could not possibly be scaled up to the given length.
      </remarks>
     </Length>
     <Normal>
      <summary>Returns a normalized copy of this vector.</summary>
      <value>A vector pointing in the same direction as this one, but with a length of 1.0 (or as
      close as floating-point precision will let us get to 1.0).
      </value>
      <remarks>This property is not valid when the length of the vector is zero, since the vector would not be
      pointing in any direction and could not possibly be scaled to the correct length.
      </remarks>
     </Normal>
    </Vector>
  </Geometry>

  <LinearEquations>
    <Solve>
      <param name="coefficients">A square matrix representing the left side of the equations, where the rows represent the individual
        equations and the columns represent the coefficients in the equations. The matrix must be invertible.
      </param>
      <param name="values">A matrix of the same height as <paramref name="coefficients"/> representing the right side of the
        equations, where each column contains the set of sums of the equation terms (i.e. what the equation equals).
      </param>
      <param name="inverse">A variable that receives the inverse of the <paramref name="coefficients" /> matrix.</param>
      <returns>
        A matrix of the same size as <paramref name="values" /> where each column contains a solution to the system of equations (using
        the values from the corresponding column in <paramref name="values" />), and each row represents a variable.
      </returns>
      <remarks>
        As an example, to solve the following set of equations:
        <code>
          4x + 2y - 2z = 10
          2x + 8y + 4z = 32
          30x + 12y - 4z = 24
        </code>
        You would construct the following coefficients matrix:
        <code>
           4  2 -2
           2  8  4
          30 12 -4
        </code>
        And the following values matrix:
        <code>
          10
          32
          24
        </code>
        The method would return a matrix containing the solution:
        <code>
          -2
           6
          -3
        </code>
      </remarks>
    </Solve>
  </LinearEquations>

  <RNG>
    <SeedSize>The number of uints that should be used to used to seed the random number generator.</SeedSize>
    <LoadStateCore>
      <summary>Loads the state of the generator, as implemented by derived classes, from a <see cref="BinaryReader" />.</summary>
    </LoadStateCore>
    <SaveStateCore>
      <summary>Saves the state of the generator, as implemented by derived classes, to a <see cref="BinaryWriter" />.</summary>
    </SaveStateCore>
    <NextUint32>
      <summary>Generates and returns a random 32-bit unsigned integer.</summary>
    </NextUint32>
  </RNG>

  <RootFinding>
    <BoundedNewtonRaphson>
      <remarks>
        This function converges quadratically on the root, making it a very effective method. It also tends to be quite accurate.
        However, it is vulnerable to pathological cases in which it can fail to find a root even when it exists. Newton-Raphson is also
        quite sensitive in requiring the initial guess to be fairly close to the root. In difficult cases, it may be better to use
        <see cref="Brent">Brent's method</see>, or even the <see cref="Subdivide">the subdivision method</see>. This implementation of
        Newton's method brackets the root within an interval to avoid shortcomings in the standard Newton's method that cause it to diverge
        wildly if it encounters a derivative near zero. Because of the bracketing, the method generally cannot find double roots. If you
        need to find a double root, you may try <see cref="UnboundedNewtonRaphson" />.
      </remarks>
    </BoundedNewtonRaphson>

    <BracketInward>
      <summary>
        Given an initial guess of an interval containing a root, divides the interval into a number of segments and returns a list
        containing the subintervals that contain a zero crossings, which usually indicate the existence of roots.
      </summary>
      <param name="function">The function to evaluate.</param>
      <param name="interval">
        An initial guess of an interval of parameter values for which the function contains a root (i.e. evaluates
        to zero).
      </param>
      <param name="segments">
        The number of equal-sized segments into which the interval should be divided when searching for subintervals
        that contain zero crossings.
      </param>
      <returns>Returns a list of the subintervals containing zero crossings.</returns>
      <remarks>
        This method doesn't necessarily find roots. It merely looks for zero crossings, which usually indicate a root but could also
        indicate a singularity or discontinuity. Also, roots that don't cross zero, such as double roots, are unlikely to be found by this
        method, but if found, could be returned in two different intervals (at their edges).
      </remarks>
    </BracketInward>

    <BracketOutward>
      <summary>
        Given an initial guess of an interval containing a root, expands the interval outward until the function values at the two
        edges cross zero (i.e. have different sign). This usually indicates a root.
      </summary>
      <param name="function">The function to evaluate.</param>
      <param name="initialGuess">
        An initial guess of an interval of parameter values for which the function contains a root (i.e.
        evaluates to zero).
      </param>
      <returns>Returns if an interval was found for which the function values cross zero, or false if no interval was found.</returns>
      <remarks>
        This method doesn't necessarily find roots. It merely looks for zero crossings, which usually indicate a root but could also
        indicate a singularity or discontinuity. Also, roots that don't cross zero, such as double roots, are unlikely to be found by this
        method.
      </remarks>
    </BracketOutward>

    <Brent>
      <remarks>
        This function converges quadratically on the root, making it a very effective method, although if you can efficiently calculate the
        derivative of the function, it might be better to use <see cref="BoundedNewtonRaphson">the Newton-Raphson</see> method.
        Newton-Raphson tends to find the root more quickly and accurately, but is vulnerable to pathological cases in which it can fail to
        find a root even when it exists. Newton-Raphson may also be more sensitive in requiring the initial guess to be close to the root.
      </remarks>
    </Brent>
    
    <FindRoot1>
      <summary>Implements the subdivision method of finding a root of a one-dimensional function.</summary>
      <param name="function">The function to evaluate.</param>
      <param name="interval">
        An interval in which a root has been bracketed. If the interval does not contain a root, the method will
        produce the wrong result.
      </param>
      <param name="accuracy">
        The accuracy to which the root will be found. The root will be refined until it is within the given distance of the true root.
      </param>
      <returns>Returns a root of the function, to within the specified accuracy. See the remarks for more details.</returns>
      <exception cref="ArgumentException">Thrown if the interval is invalid, the interval does not bracket a zero crossing, or the function
        cannot find a zero crossing within the given interval to the desired accuracy.
      </exception>
      <remarks>
        Specifically, this function homes in on the point at the function changes sign. This usually indicates a root, but it could
        also indicate a singularity or discontinuity. Therefore, if the interval brackets one of these rather than a root, the function
        will locate the singularity or discontinuity instead.
      </remarks>
    </FindRoot1>

    <UnboundedNewtonRaphson>
      <remarks>This function converges quadratically on the root, making it a very effective method. It also tends to be quite accurate.
        However, it is vulnerable to pathological cases in which it can fail to find a root even when it exists. Newton-Raphson is also
        quite sensitive in requiring the initial guess to be fairly close to the root. This implementation of Newton's method does not
        bracket the root and may diverge wildly. In general, it is better to use <see cref="BoundedNewtonRaphson" />, but that method
        usually cannot be used to find double roots, while this one can.
      </remarks>
    </UnboundedNewtonRaphson>

    <Subdivide>
      <remarks>
        This function converges linearly on the root, which makes it rather slow compared to other methods such as
        <see cref="Brent">Brent's method</see> and <see cref="BoundedNewtonRaphson">the Newton-Raphson method</see>, but it is very simple
        and reliable, and a good method to try as a last resort.
      </remarks>
    </Subdivide>
  </RootFinding>
</Math>